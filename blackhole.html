<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Mouse Gravity Black Hole</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #00ffff;
            font-family: sans-serif;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div id="instructions">Move mouse to attract particles</div>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 500,
            spawnRadius: 0.25,    // How far from mouse particles appear
            killRadius: 0.01,      // How close they get before disappearing
            spawnRate: 100,       // Particles spawned per frame
            gravityStrength: 1, // Strength of the pull
            swirlStrength: 0.11,  // Initial sideways velocity (the spiral)
            color: 0x00ffff       // Cyan
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- MOUSE TRACKING ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(9999, 9999); // Start off-screen
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Invisible plane at Z=0
        const targetPos = new THREE.Vector3(0, 0, 0);

        window.addEventListener('mousemove', (event) => {
            // Normalize mouse coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const velocities = new Float32Array(CONFIG.particleCount * 3);
        const lifes = new Float32Array(CONFIG.particleCount); // 0 = dead, 1 = alive

        // Initialize all particles as "dead" (off-screen)
        for (let i = 0; i < CONFIG.particleCount; i++) {
            positions[i * 3] = 99999;
            positions[i * 3 + 1] = 99999;
            positions[i * 3 + 2] = 0;
            lifes[i] = 0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Material
        const material = new THREE.PointsMaterial({
            color: CONFIG.color,
            size: 0.15,
            blending: THREE.AdditiveBlending, // Makes overlapping particles glow
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Find where the mouse is in the 3D world
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, targetPos);

            const pos = geometry.attributes.position.array;

            // Loop through all particles
            let spawnedThisFrame = 0;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                const isAlive = lifes[i] === 1;

                if (!isAlive) {
                    // --- SPAWN LOGIC ---
                    // Only spawn if we haven't hit the limit for this frame
                    if (spawnedThisFrame < CONFIG.spawnRate) {
                        spawnedThisFrame++;
                        lifes[i] = 1; // Wake up

                        // Spawn on a random point on the circle edge
                        const angle = Math.random() * Math.PI * 2;

                        pos[i3] = targetPos.x + Math.cos(angle) * CONFIG.spawnRadius;
                        pos[i3 + 1] = targetPos.y + Math.sin(angle) * CONFIG.spawnRadius;
                        pos[i3 + 2] = 0; // Flat plane

                        // Give it tangential velocity (swirl) so it doesn't fall straight in
                        // Perpendicular vectors: (-y, x)
                        velocities[i3] = -Math.sin(angle) * CONFIG.swirlStrength;
                        velocities[i3 + 1] = Math.cos(angle) * CONFIG.swirlStrength;
                        velocities[i3 + 2] = 0;
                    }
                } else {
                    // --- PHYSICS LOGIC ---

                    // Calculate distance to mouse
                    const dx = targetPos.x - pos[i3];
                    const dy = targetPos.y - pos[i3 + 1];
                    const dz = targetPos.z - pos[i3 + 2]; // Z is mostly 0, but good for completeness

                    // Distance Squared (faster than sqrt)
                    const distSq = dx * dx + dy * dy + dz * dz;

                    // CHECK: Event Horizon (Death)
                    if (distSq < (CONFIG.killRadius * CONFIG.killRadius)) {
                        lifes[i] = 0; // Kill
                        pos[i3] = 99999; // Hide
                        continue;
                    }

                    // GRAVITY: Force = 1 / distance
                    // We add a small number (0.1) to avoid division by zero glitches
                    const force = CONFIG.gravityStrength / (distSq + 0.1);

                    // Update Velocity
                    velocities[i3] += dx * force * 0.01;
                    velocities[i3 + 1] += dy * force * 0.01;
                    velocities[i3 + 2] += dz * force * 0.01;

                    // Optional: Friction to stop them orbiting forever (makes them fall in eventually)
                    velocities[i3] *= 0.98;
                    velocities[i3 + 1] *= 0.98;
                    velocities[i3 + 2] *= 0.98;

                    // Update Position
                    pos[i3] += velocities[i3];
                    pos[i3 + 1] += velocities[i3 + 1];
                    pos[i3 + 2] += velocities[i3 + 2];
                }
            }

            // Tell Three.js the array data has changed
            geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>